<!-- This file displays the animated SVG link to the GitHub repository 
in the top right corner -->


<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mitiq.zne.inference &#8212; Mitiq 0.14.0dev documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/styles/pydata-sphinx-theme.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../index.html">
  <img src="../../../_static/mitiq-logo.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../readme.html">
  <a href="https://github.com/unitaryfund/mitiq">
  </a>
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../guide/guide.html">
  Users Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../examples/examples.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../apidoc.html">
  API-doc
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../toc_contributing.html">
  Contributing
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../changelog.html">
  Changelog
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../zz_bibliography.html">
  References
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
    
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for mitiq.zne.inference</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2020 Unitary Fund</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;Classes corresponding to different zero-noise extrapolation methods.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">matplotlib.figure</span> <span class="kn">import</span> <span class="n">Figure</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.lib.polynomial</span> <span class="kn">import</span> <span class="n">RankWarning</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span><span class="p">,</span> <span class="n">OptimizeWarning</span>
<span class="kn">from</span> <span class="nn">cirq</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="kn">from</span> <span class="nn">mitiq._typing</span> <span class="kn">import</span> <span class="n">QPROGRAM</span><span class="p">,</span> <span class="n">QuantumResult</span>
<span class="kn">from</span> <span class="nn">mitiq.observable</span> <span class="kn">import</span> <span class="n">Observable</span>
<span class="kn">from</span> <span class="nn">mitiq.executor</span> <span class="kn">import</span> <span class="n">Executor</span>
<span class="kn">from</span> <span class="nn">mitiq.zne.scaling</span> <span class="kn">import</span> <span class="n">fold_gates_at_random</span>
<span class="kn">from</span> <span class="nn">mitiq.interface</span> <span class="kn">import</span> <span class="n">accept_any_qprogram_as_input</span>


<span class="n">ExtrapolationResult</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="nb">float</span><span class="p">,</span>  <span class="c1"># The zero-noise value.</span>
    <span class="n">Tuple</span><span class="p">[</span>
        <span class="nb">float</span><span class="p">,</span>  <span class="c1"># The zero-noise value.</span>
        <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>  <span class="c1"># The (estimated) error on the zero-noise value.</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>  <span class="c1"># Optimal parameters found during fitting.</span>
        <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>  <span class="c1"># Covariance of fitting parameters.</span>
        <span class="n">Callable</span><span class="p">[[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>  <span class="c1"># Function that was fit.</span>
    <span class="p">],</span>
<span class="p">]</span>


<div class="viewcode-block" id="ExtrapolationError"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.ExtrapolationError">[docs]</a><span class="k">class</span> <span class="nc">ExtrapolationError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Error raised by :class:`.Factory` objects when</span>
<span class="sd">    the extrapolation fit fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<span class="n">_EXTR_ERR</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;The extrapolation fit failed to converge.&quot;</span>
    <span class="s2">&quot; The problem may be solved by switching to a more stable&quot;</span>
    <span class="s2">&quot; extrapolation model such as `LinearFactory`.&quot;</span>
<span class="p">)</span>


<div class="viewcode-block" id="ExtrapolationWarning"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.ExtrapolationWarning">[docs]</a><span class="k">class</span> <span class="nc">ExtrapolationWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warning raised by :class:`.Factory` objects when</span>
<span class="sd">    the extrapolation fit is ill-conditioned.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<span class="n">_EXTR_WARN</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;The extrapolation fit may be ill-conditioned.&quot;</span>
    <span class="s2">&quot; Likely, more data points are necessary to fit the parameters&quot;</span>
    <span class="s2">&quot; of the model.&quot;</span>
<span class="p">)</span>

<span class="n">DATA_MISSING_ERR</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;Data is either ill-defined or not enough to evaluate the required&quot;</span>
    <span class="s2">&quot; information. Please make sure that the &#39;run&#39; and &#39;reduce&#39; methods&quot;</span>
    <span class="s2">&quot; have been called and that enough expectation values have been measured.&quot;</span>
<span class="p">)</span>


<div class="viewcode-block" id="ConvergenceWarning"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.ConvergenceWarning">[docs]</a><span class="k">class</span> <span class="nc">ConvergenceWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warning raised by :class:`.Factory` objects when</span>
<span class="sd">    their `run_classical` method fails to converge.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<span class="nd">@accept_any_qprogram_as_input</span>
<span class="k">def</span> <span class="nf">_check_circuit_length</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Raises a warning if the circuit is too short.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">all_operations</span><span class="p">()))</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The input circuit is very short. &quot;</span>
            <span class="s2">&quot;This may reduce the accuracy of noise scaling.&quot;</span>
        <span class="p">)</span>


<div class="viewcode-block" id="mitiq_curve_fit"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.mitiq_curve_fit">[docs]</a><span class="k">def</span> <span class="nf">mitiq_curve_fit</span><span class="p">(</span>
    <span class="n">ansatz</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">exp_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">init_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Fits the ansatz to the (scale factor, expectation value) data using</span>
<span class="sd">    ``scipy.optimize.curve_fit``, returning the optimal parameters and</span>
<span class="sd">    covariance matrix of the parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        ansatz: The model function used for zero-noise extrapolation. The first</span>
<span class="sd">            argument is the noise scale variable, the remaining arguments are</span>
<span class="sd">            the parameters to fit.</span>
<span class="sd">        scale_factors: The array of noise scale factors.</span>
<span class="sd">        exp_values: The array of expectation values.</span>
<span class="sd">        init_params: Initial guess for the parameters. If None, the initial</span>
<span class="sd">            values are set to 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The array of optimal parameters and the covariance matrix of the</span>
<span class="sd">        parameters. If the fit is ill-conditioned, the covariance matrix may</span>
<span class="sd">        contain np.inf elements.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ExtrapolationError: If the extrapolation fit fails.</span>
<span class="sd">        ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">warn_list</span><span class="p">:</span>
            <span class="n">opt_params</span><span class="p">,</span> <span class="n">params_cov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
                <span class="n">ansatz</span><span class="p">,</span> <span class="n">scale_factors</span><span class="p">,</span> <span class="n">exp_values</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">init_params</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">warn</span> <span class="ow">in</span> <span class="n">warn_list</span><span class="p">:</span>
            <span class="c1"># replace OptimizeWarning with ExtrapolationWarning</span>
            <span class="k">if</span> <span class="n">warn</span><span class="o">.</span><span class="n">category</span> <span class="ow">is</span> <span class="n">OptimizeWarning</span><span class="p">:</span>
                <span class="n">warn</span><span class="o">.</span><span class="n">category</span> <span class="o">=</span> <span class="n">ExtrapolationWarning</span>
                <span class="n">warn</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">_EXTR_WARN</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># re-raise all warnings</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn_explicit</span><span class="p">(</span>
                <span class="n">warn</span><span class="o">.</span><span class="n">message</span><span class="p">,</span> <span class="n">warn</span><span class="o">.</span><span class="n">category</span><span class="p">,</span> <span class="n">warn</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">warn</span><span class="o">.</span><span class="n">lineno</span>
            <span class="p">)</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ExtrapolationError</span><span class="p">(</span><span class="n">_EXTR_ERR</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">opt_params</span><span class="p">),</span> <span class="n">params_cov</span></div>


<div class="viewcode-block" id="mitiq_polyfit"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.mitiq_polyfit">[docs]</a><span class="k">def</span> <span class="nf">mitiq_polyfit</span><span class="p">(</span>
    <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">exp_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">deg</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Fits the ansatz to the (scale factor, expectation value) data using</span>
<span class="sd">    ``numpy.polyfit``, returning the optimal parameters and covariance matrix</span>
<span class="sd">    of the parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        scale_factors: The array of noise scale factors.</span>
<span class="sd">        exp_values: The array of expectation values.</span>
<span class="sd">        deg: The degree of the polynomial fit.</span>
<span class="sd">        weights: Optional array of weights for each sampled point.</span>
<span class="sd">            This is used to make a weighted least squares fit.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The optimal parameters and covariance matrix of the parameters.</span>
<span class="sd">        If there is not enough data to estimate the covariance matrix, it is</span>
<span class="sd">        returned as None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">warn_list</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">opt_params</span><span class="p">,</span> <span class="n">params_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span>
                <span class="n">scale_factors</span><span class="p">,</span> <span class="n">exp_values</span><span class="p">,</span> <span class="n">deg</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">):</span>
            <span class="n">opt_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">,</span> <span class="n">exp_values</span><span class="p">,</span> <span class="n">deg</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">params_cov</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">warn</span> <span class="ow">in</span> <span class="n">warn_list</span><span class="p">:</span>
        <span class="c1"># replace RankWarning with ExtrapolationWarning</span>
        <span class="k">if</span> <span class="n">warn</span><span class="o">.</span><span class="n">category</span> <span class="ow">is</span> <span class="n">RankWarning</span><span class="p">:</span>
            <span class="n">warn</span><span class="o">.</span><span class="n">category</span> <span class="o">=</span> <span class="n">ExtrapolationWarning</span>
            <span class="n">warn</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">_EXTR_WARN</span>  <span class="c1"># type: ignore</span>
        <span class="c1"># re-raise all warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn_explicit</span><span class="p">(</span>
            <span class="n">warn</span><span class="o">.</span><span class="n">message</span><span class="p">,</span> <span class="n">warn</span><span class="o">.</span><span class="n">category</span><span class="p">,</span> <span class="n">warn</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">warn</span><span class="o">.</span><span class="n">lineno</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">opt_params</span><span class="p">),</span> <span class="n">params_cov</span></div>


<div class="viewcode-block" id="Factory"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory">[docs]</a><span class="k">class</span> <span class="nc">Factory</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract base class which performs the classical parts of zero-noise</span>
<span class="sd">    extrapolation. This minimally includes:</span>

<span class="sd">        * scaling circuits,</span>
<span class="sd">        * sending jobs to execute,</span>
<span class="sd">        * collecting the results,</span>
<span class="sd">        * fitting the collected data,</span>
<span class="sd">        * Extrapolating to the zero-noise limit.</span>

<span class="sd">    If all scale factors are set a priori, the jobs can be batched. This is</span>
<span class="sd">    handled by a BatchedFactory.</span>

<span class="sd">    If the next scale factor depends on the previous history of results,</span>
<span class="sd">    jobs are run sequentially. This is handled by an AdaptiveFactory.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_instack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outstack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opt_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params_cov</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zne_limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zne_error</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zne_curve</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_already_reduced</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Factory.get_scale_factors"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.get_scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">get_scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the scale factors at which the factory has computed</span>
<span class="sd">        expectation values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">params</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instack</span><span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Factory.get_expectation_values"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.get_expectation_values">[docs]</a>    <span class="k">def</span> <span class="nf">get_expectation_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the expectation values computed by the factory.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outstack</span><span class="p">)</span></div>

<div class="viewcode-block" id="Factory.get_optimal_parameters"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.get_optimal_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_optimal_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the optimal model parameters produced by the extrapolation</span>
<span class="sd">        fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">DATA_MISSING_ERR</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_opt_params</span><span class="p">)</span></div>

<div class="viewcode-block" id="Factory.get_parameters_covariance"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.get_parameters_covariance">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters_covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the covariance matrix of the model parameters produced by</span>
<span class="sd">        the extrapolation fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">DATA_MISSING_ERR</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params_cov</span><span class="p">)</span></div>

<div class="viewcode-block" id="Factory.get_zero_noise_limit"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.get_zero_noise_limit">[docs]</a>    <span class="k">def</span> <span class="nf">get_zero_noise_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the last evaluation of the zero-noise limit</span>
<span class="sd">        computed by the factory. To re-evaluate</span>
<span class="sd">        its value, the method &#39;reduce&#39; should be called first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zne_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">DATA_MISSING_ERR</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zne_limit</span></div>

<div class="viewcode-block" id="Factory.get_zero_noise_limit_error"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.get_zero_noise_limit_error">[docs]</a>    <span class="k">def</span> <span class="nf">get_zero_noise_limit_error</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the extrapolation error representing the uncertainty</span>
<span class="sd">        affecting the zero-noise limit. It is deduced by error propagation</span>
<span class="sd">        from the covariance matrix associated to the fit parameters.</span>

<span class="sd">        Note: this quantity is only related to the ability of the model</span>
<span class="sd">            to fit the measured data. Therefore, it may underestimate the</span>
<span class="sd">            actual error existing between the zero-noise limit and the</span>
<span class="sd">            true ideal expectation value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zne_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">DATA_MISSING_ERR</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zne_error</span></div>

<div class="viewcode-block" id="Factory.get_extrapolation_curve"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.get_extrapolation_curve">[docs]</a>    <span class="k">def</span> <span class="nf">get_extrapolation_curve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns the extrapolation curve, i.e., a function which</span>
<span class="sd">        inputs a noise scale factor and outputs the associated expectation</span>
<span class="sd">        value. This function is the solution of the regression problem</span>
<span class="sd">        used to evaluate the zero-noise extrapolation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zne_curve</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">DATA_MISSING_ERR</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zne_curve</span></div>

<div class="viewcode-block" id="Factory.run"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.run">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">qp</span><span class="p">:</span> <span class="n">QPROGRAM</span><span class="p">,</span>
        <span class="n">executor</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Executor</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">QuantumResult</span><span class="p">]],</span>
        <span class="n">observable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Observable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_noise</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">QPROGRAM</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">QPROGRAM</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">fold_gates_at_random</span><span class="p">,</span>
        <span class="n">num_to_average</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Factory&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calls the executor function on noise-scaled quantum circuit and</span>
<span class="sd">        stores the results.</span>

<span class="sd">        Args:</span>
<span class="sd">            qp: Quantum circuit to scale noise in.</span>
<span class="sd">            executor: A ``mitiq.Executor`` or a function which inputs a (list</span>
<span class="sd">                of) quantum circuits and outputs a (list of)</span>
<span class="sd">                ``mitiq.QuantumResult`` s.</span>
<span class="sd">            observable: Observable to compute the expectation value of. If</span>
<span class="sd">                None, the `executor` must return an expectation value.</span>
<span class="sd">                Otherwise, the `QuantumResult` returned by `executor` is used</span>
<span class="sd">                to compute the expectation of the observable.</span>
<span class="sd">            scale_noise: Function which inputs a quantum circuit and outputs</span>
<span class="sd">                a noise-scaled quantum circuit.</span>
<span class="sd">            num_to_average: Number of times the executor function is called</span>
<span class="sd">                on each noise-scaled quantum circuit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Factory.run_classical"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.run_classical">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">run_classical</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale_factor_to_expectation_value</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Factory&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calls the function scale_factor_to_expectation_value at each scale</span>
<span class="sd">        factor of the factory, and stores the results.</span>

<span class="sd">        Args:</span>
<span class="sd">            scale_factor_to_expectation_value: A function which inputs a scale</span>
<span class="sd">                factor and outputs an expectation value. This does not have to</span>
<span class="sd">                involve a quantum processor making this a &quot;classical analogue&quot;</span>
<span class="sd">                of the run method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="Factory.push"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.push">[docs]</a>    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">instack_val</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">outstack_val</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Factory&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Appends &quot;instack_val&quot; to &quot;self._instack&quot; and &quot;outstack_val&quot; to</span>
<span class="sd">        &quot;self._outstack&quot;. Each time a new expectation value is computed this</span>
<span class="sd">        method should be used to update the internal state of the Factory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_already_reduced</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;You are pushing new data into a factory object despite its &quot;</span>
                <span class="s2">&quot;.reduce() method has already been called. Please make &quot;</span>
                <span class="s2">&quot;sure your intention is to append new data to the stack of &quot;</span>
                <span class="s2">&quot;previous data. Otherwise, the method .reset() can be used &quot;</span>
                <span class="s2">&quot;to clean the internal state of the factory.&quot;</span><span class="p">,</span>
                <span class="n">ExtrapolationWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_instack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instack_val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outstack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outstack_val</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Factory.plot_data"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.plot_data">[docs]</a>    <span class="k">def</span> <span class="nf">plot_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Figure</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a figure which is a scatter plot of (x, y) data where x are</span>
<span class="sd">        scale factors at which expectation values have been computed, and y are</span>
<span class="sd">        the associated expectation values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig: A 2D scatter plot described above.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_scale_factors</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_expectation_values</span><span class="p">(),</span>
            <span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">markeredgecolor</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Data&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Noise scale factor&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Expectation value&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="Factory.plot_fit"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.plot_fit">[docs]</a>    <span class="k">def</span> <span class="nf">plot_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Figure</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a figure which plots the experimental data as well as the</span>
<span class="sd">        best fit curve.</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig: A figure which plots the best fit curve as well as the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_data</span><span class="p">()</span>

        <span class="n">smooth_scale_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scale_factors</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">smooth_expectations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_extrapolation_curve</span><span class="p">()(</span><span class="n">scale_factor</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">scale_factor</span> <span class="ow">in</span> <span class="n">smooth_scale_factors</span>
        <span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">smooth_scale_factors</span><span class="p">,</span>
            <span class="n">smooth_expectations</span><span class="p">,</span>
            <span class="s2">&quot;--&quot;</span><span class="p">,</span>
            <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Best fit&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="Factory.reset"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.Factory.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Factory&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Resets the internal state of the Factory.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_instack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outstack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opt_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zne_limit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zne_error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_already_reduced</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>


<div class="viewcode-block" id="BatchedFactory"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.BatchedFactory">[docs]</a><span class="k">class</span> <span class="nc">BatchedFactory</span><span class="p">(</span><span class="n">Factory</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class of a non-adaptive Factory initialized with a</span>
<span class="sd">    pre-determined set of scale factors.</span>

<span class="sd">    Specific (non-adaptive) extrapolation algorithms are derived from this</span>
<span class="sd">    class by defining the `reduce` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">shot_list</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Constructs a BatchedFactory.</span>

<span class="sd">        Args:</span>
<span class="sd">            scale_factors: Sequence of noise scale factors at which expectation</span>
<span class="sd">                values should be measured.</span>
<span class="sd">            shot_list: Optional sequence of integers corresponding to the</span>
<span class="sd">                number of samples taken for each expectation value. If this</span>
<span class="sd">                argument is explicitly passed to the factory, it must have the</span>
<span class="sd">                same length of scale_factors and the executor function must</span>
<span class="sd">                accept &quot;shots&quot; as a valid keyword argument.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the number of scale factors is less than 2.</span>
<span class="sd">            TypeError: If shot_list is provided and has any non-integer values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least 2 scale factors are necessary.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shot_list</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shot_list</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">shots</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">shots</span> <span class="ow">in</span> <span class="n">shot_list</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;The optional argument shot_list must be None &quot;</span>
                <span class="s2">&quot;or a valid iterator of integers.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">shot_list</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shot_list</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;The arguments scale_factors and shot_list&quot;</span>
                <span class="s2">&quot; must have the same length.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; But len(scale_factors) is </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; and len(shot_list) is </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shot_list</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_scale_factors</span> <span class="o">=</span> <span class="n">scale_factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shot_list</span> <span class="o">=</span> <span class="n">shot_list</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">BatchedFactory</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="BatchedFactory.extrapolate"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.BatchedFactory.extrapolate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExtrapolationResult</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the extrapolation to the zero-noise limit.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="BatchedFactory.reduce"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.BatchedFactory.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the zero-noise limit found by fitting according to</span>
<span class="sd">        the factory&#39;s extrapolation method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The zero-noise limit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zne_limit</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zne_error</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_params</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params_cov</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zne_curve</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_scale_factors</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_expectation_values</span><span class="p">(),</span>
            <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_already_reduced</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zne_limit</span></div>

<div class="viewcode-block" id="BatchedFactory.run"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.BatchedFactory.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">qp</span><span class="p">:</span> <span class="n">QPROGRAM</span><span class="p">,</span>
        <span class="n">executor</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Executor</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">QuantumResult</span><span class="p">]],</span>
        <span class="n">observable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Observable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_noise</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">QPROGRAM</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">QPROGRAM</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">fold_gates_at_random</span><span class="p">,</span>
        <span class="n">num_to_average</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BatchedFactory&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Computes the expectation values at each scale factor and stores them</span>
<span class="sd">        in the factory. If the executor returns a single expectation value, the</span>
<span class="sd">        circuits are run sequentially. If the executor is batched and returns</span>
<span class="sd">        a list of expectation values (one for each circuit), then the circuits</span>
<span class="sd">        are sent to the backend as a single job. To detect if an executor is</span>
<span class="sd">        batched, it must be annotated with a return type that is one of the</span>
<span class="sd">        following:</span>

<span class="sd">            * Iterable[float]</span>
<span class="sd">            * List[float]</span>
<span class="sd">            * Sequence[float]</span>
<span class="sd">            * Tuple[float]</span>
<span class="sd">            * numpy.ndarray</span>

<span class="sd">        Args:</span>
<span class="sd">            qp: Quantum circuit to run.</span>
<span class="sd">            executor: A ``mitiq.Executor`` or a function which inputs a (list</span>
<span class="sd">                of) quantum circuits and outputs a (list of)</span>
<span class="sd">                ``mitiq.QuantumResult`` s.</span>
<span class="sd">            observable: Observable to compute the expectation value of. If</span>
<span class="sd">                None, the `executor` must return an expectation value.</span>
<span class="sd">                Otherwise, the `QuantumResult` returned by `executor` is used</span>
<span class="sd">                to compute the expectation of the observable.</span>
<span class="sd">            scale_noise: Noise scaling function.</span>
<span class="sd">            num_to_average: The number of circuits executed for each noise</span>
<span class="sd">                scale factor. This parameter can be used to increase the</span>
<span class="sd">                precision of the &quot;executor&quot; or to average the effect of a</span>
<span class="sd">                non-deterministic &quot;scale_noise&quot; function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_batch_populate_instack</span><span class="p">()</span>

        <span class="n">_check_circuit_length</span><span class="p">(</span><span class="n">qp</span><span class="p">)</span>

        <span class="c1"># Get all noise-scaled circuits to run.</span>
        <span class="n">to_run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_circuits</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="n">scale_noise</span><span class="p">,</span> <span class="n">num_to_average</span><span class="p">)</span>

        <span class="c1"># Run all circuits.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">executor</span><span class="p">,</span> <span class="n">Executor</span><span class="p">):</span>
            <span class="n">executor</span> <span class="o">=</span> <span class="n">Executor</span><span class="p">(</span><span class="n">executor</span><span class="p">)</span>

        <span class="c1"># Get the list of keywords associated to each circuit in &quot;to_run&quot;.</span>
        <span class="n">kwargs_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_keyword_args</span><span class="p">(</span><span class="n">num_to_average</span><span class="p">)</span>

        <span class="c1"># If there are different keyword args, run each circuit individually.</span>
        <span class="c1"># https://stackoverflow.com/questions/1151658/python-hashable-dicts.</span>
        <span class="k">class</span> <span class="nc">HashableDict</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span>
            <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>  <span class="c1"># type: ignore[override]</span>
                <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">HashableDict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="n">kwargs_list</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">circuit</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">to_run</span><span class="p">,</span> <span class="n">kwargs_list</span><span class="p">):</span>
                <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="n">executor</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
                        <span class="n">circuit</span><span class="p">,</span> <span class="n">observable</span><span class="p">,</span> <span class="n">force_run_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Else, run all circuits.</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
                <span class="n">to_run</span><span class="p">,</span> <span class="n">observable</span><span class="p">,</span> <span class="n">force_run_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># Reshape &quot;res&quot; to have &quot;num_to_average&quot; columns</span>
        <span class="n">reshaped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_to_average</span><span class="p">))</span>

        <span class="c1"># Average the &quot;num_to_average&quot; columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outstack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">reshaped</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BatchedFactory.run_classical"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.BatchedFactory.run_classical">[docs]</a>    <span class="k">def</span> <span class="nf">run_classical</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">scale_factor_to_expectation_value</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BatchedFactory&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Computes expectation values by calling the input function at each</span>
<span class="sd">        scale factor.</span>

<span class="sd">        Args:</span>
<span class="sd">            scale_factor_to_expectation_value: Function mapping a noise scale</span>
<span class="sd">                factor to an expectation value. If shot_list is not None,</span>
<span class="sd">                &quot;shots&quot; must be an argument of this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_batch_populate_instack</span><span class="p">()</span>
        <span class="n">kwargs_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_keyword_args</span><span class="p">(</span><span class="n">num_to_average</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_outstack</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">scale_factor_to_expectation_value</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale_factors</span><span class="p">,</span> <span class="n">kwargs_list</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_generate_circuits</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">circuit</span><span class="p">:</span> <span class="n">QPROGRAM</span><span class="p">,</span>
        <span class="n">scale_noise</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">QPROGRAM</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">QPROGRAM</span><span class="p">],</span>
        <span class="n">num_to_average</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">QPROGRAM</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns all noise-scaled circuits to run.</span>

<span class="sd">        Args:</span>
<span class="sd">            circuit: Base circuit to scale noise in.</span>
<span class="sd">            scale_noise: Noise scaling function.</span>
<span class="sd">            num_to_average: Number of times to call scale_noise at each scale</span>
<span class="sd">                factor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_run</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">scale_factor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scale_factors</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_average</span><span class="p">):</span>
                <span class="n">to_run</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale_noise</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">to_run</span>

    <span class="k">def</span> <span class="nf">_batch_populate_instack</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Populates the instack with all computed values.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shot_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_instack</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">:</span> <span class="n">scale</span><span class="p">,</span> <span class="s2">&quot;shots&quot;</span><span class="p">:</span> <span class="n">shots</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">scale</span><span class="p">,</span> <span class="n">shots</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale_factors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shot_list</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_instack</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">:</span> <span class="n">scale</span><span class="p">}</span> <span class="k">for</span> <span class="n">scale</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_factors</span>
            <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_keyword_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_to_average</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of keyword dictionaries to be used for</span>
<span class="sd">        executing the circuits generated by the method &quot;_generate_circuits&quot;.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_to_average: The number of times the same keywords are used</span>
<span class="sd">                for each scale factor. This should correspond to the number</span>
<span class="sd">                of circuits executed for each scale factor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The output list of keyword dictionaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instack</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">)</span>

        <span class="c1"># Repeat each keyword num_to_average times</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">params</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_average</span><span class="p">)]</span></div>


<div class="viewcode-block" id="AdaptiveFactory"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.AdaptiveFactory">[docs]</a><span class="k">class</span> <span class="nc">AdaptiveFactory</span><span class="p">(</span><span class="n">Factory</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class designed to adaptively produce a new noise scaling</span>
<span class="sd">    parameter based on a historical stack of previous noise scale parameters</span>
<span class="sd">    (&quot;self._instack&quot;) and previously estimated expectation values</span>
<span class="sd">    (&quot;self._outstack&quot;).</span>

<span class="sd">    Specific zero-noise extrapolation algorithms which are adaptive are derived</span>
<span class="sd">    from this class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AdaptiveFactory.next"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.AdaptiveFactory.next">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns a dictionary of parameters to execute a circuit at.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="AdaptiveFactory.is_converged"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.AdaptiveFactory.is_converged">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">is_converged</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns True if all needed expectation values have been computed,</span>
<span class="sd">        else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="AdaptiveFactory.reduce"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.AdaptiveFactory.reduce">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the extrapolation to the zero-noise limit.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="AdaptiveFactory.run_classical"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.AdaptiveFactory.run_classical">[docs]</a>    <span class="k">def</span> <span class="nf">run_classical</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale_factor_to_expectation_value</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">max_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AdaptiveFactory&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evaluates a sequence of expectation values until enough</span>
<span class="sd">        data is collected (or iterations reach &quot;max_iterations&quot;).</span>

<span class="sd">        Args:</span>
<span class="sd">            scale_factor_to_expectation_value: Function mapping a noise scale</span>
<span class="sd">                factor to an expectation value. If shot_list is not None,</span>
<span class="sd">                &quot;shots&quot; must be an argument of this function.</span>
<span class="sd">            max_iterations: Maximum number of iterations (optional).</span>
<span class="sd">                Default: 100.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ConvergenceWarning: If iteration loop stops before convergence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reset the instack, outstack, and optimal parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_converged</span><span class="p">()</span> <span class="ow">and</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="n">max_iterations</span><span class="p">:</span>
            <span class="n">next_in_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="n">next_exec_params</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">next_in_params</span><span class="p">)</span>

            <span class="c1"># Get next scale factor and remove it from next_exec_params</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">next_exec_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">)</span>
            <span class="n">next_expval</span> <span class="o">=</span> <span class="n">scale_factor_to_expectation_value</span><span class="p">(</span>
                <span class="n">scale_factor</span><span class="p">,</span> <span class="o">**</span><span class="n">next_exec_params</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">next_in_params</span><span class="p">,</span> <span class="n">next_expval</span><span class="p">)</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="n">max_iterations</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Factory iteration loop stopped before convergence. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Maximum number of iterations (</span><span class="si">{</span><span class="n">max_iterations</span><span class="si">}</span><span class="s2">) &quot;</span>
                <span class="s2">&quot;was reached.&quot;</span><span class="p">,</span>
                <span class="n">ConvergenceWarning</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AdaptiveFactory.run"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.AdaptiveFactory.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">qp</span><span class="p">:</span> <span class="n">QPROGRAM</span><span class="p">,</span>
        <span class="n">executor</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Executor</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">QuantumResult</span><span class="p">]],</span>
        <span class="n">observable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Observable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_noise</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">QPROGRAM</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">QPROGRAM</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">fold_gates_at_random</span><span class="p">,</span>
        <span class="n">num_to_average</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">max_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AdaptiveFactory&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evaluates a sequence of expectation values by executing quantum</span>
<span class="sd">        circuits until enough data is collected (or iterations reach</span>
<span class="sd">        &quot;max_iterations&quot;).</span>

<span class="sd">        Args:</span>
<span class="sd">            qp: Circuit to mitigate.</span>
<span class="sd">            executor: A ``mitiq.Executor`` or a function which inputs a (list</span>
<span class="sd">                of) quantum circuits and outputs a (list of)</span>
<span class="sd">                ``mitiq.QuantumResult`` s.</span>
<span class="sd">            observable: Observable to compute the expectation value of. If</span>
<span class="sd">                None, the `executor` must return an expectation value.</span>
<span class="sd">                Otherwise, the `QuantumResult` returned by `executor` is used</span>
<span class="sd">                to compute the expectation of the observable.</span>
<span class="sd">            scale_noise: Function that scales the noise level of a quantum</span>
<span class="sd">                circuit.</span>
<span class="sd">            num_to_average: Number of times expectation values are computed by</span>
<span class="sd">                the executor after each call to scale_noise, then averaged.</span>
<span class="sd">            max_iterations: Maximum number of iterations (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_check_circuit_length</span><span class="p">(</span><span class="n">qp</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">executor</span><span class="p">,</span> <span class="n">Executor</span><span class="p">):</span>
            <span class="n">executor</span> <span class="o">=</span> <span class="n">Executor</span><span class="p">(</span><span class="n">executor</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">scale_factor_to_expectation_value</span><span class="p">(</span>
            <span class="n">scale_factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="o">**</span><span class="n">exec_params</span><span class="p">:</span> <span class="n">Any</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;Evaluates the quantum expectation value for a given</span>
<span class="sd">            scale_factor and other executor parameters.&quot;&quot;&quot;</span>
            <span class="n">to_run</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">scale_noise</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_average</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">expectation_values</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>  <span class="c1"># type: ignore[union-attr]</span>
                <span class="n">to_run</span><span class="p">,</span> <span class="n">observable</span><span class="p">,</span> <span class="n">force_run_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">exec_params</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">expectation_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_classical</span><span class="p">(</span>
            <span class="n">scale_factor_to_expectation_value</span><span class="p">,</span> <span class="n">max_iterations</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="PolyFactory"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.PolyFactory">[docs]</a><span class="k">class</span> <span class="nc">PolyFactory</span><span class="p">(</span><span class="n">BatchedFactory</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Factory object implementing a zero-noise extrapolation algorithm based on</span>
<span class="sd">    a polynomial fit.</span>

<span class="sd">    Args:</span>
<span class="sd">        scale_factors: Sequence of noise scale factors at which</span>
<span class="sd">            expectation values should be measured.</span>
<span class="sd">        order: Extrapolation order (degree of the polynomial fit).</span>
<span class="sd">            It cannot exceed len(scale_factors) - 1.</span>
<span class="sd">        shot_list: Optional sequence of integers corresponding to the number</span>
<span class="sd">            of samples taken for each expectation value. If this</span>
<span class="sd">            argument is explicitly passed to the factory, it must have</span>
<span class="sd">            the same length of scale_factors and the executor function</span>
<span class="sd">            must accept &quot;shots&quot; as a valid keyword argument.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If data is not consistent with the extrapolation model.</span>
<span class="sd">        ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>

<span class="sd">    Note:</span>
<span class="sd">        RichardsonFactory and LinearFactory are special cases of PolyFactory.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">shot_list</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Instantiates a new object of this Factory class.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The extrapolation order cannot exceed len(scale_factors) - 1.&quot;</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PolyFactory</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">,</span> <span class="n">shot_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;order&quot;</span><span class="p">:</span> <span class="n">order</span><span class="p">}</span>

<div class="viewcode-block" id="PolyFactory.extrapolate"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.PolyFactory.extrapolate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">exp_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">full_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExtrapolationResult</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Static method which evaluates a polynomial extrapolation to the</span>
<span class="sd">        zero-noise limit.</span>

<span class="sd">        Args:</span>
<span class="sd">            scale_factors: The array of noise scale factors.</span>
<span class="sd">            exp_values: The array of expectation values.</span>
<span class="sd">            order: The extrapolation order (degree of the polynomial fit).</span>
<span class="sd">            full_output: If False (default), only the zero-noise limit is</span>
<span class="sd">                returned. If True, additional information about the</span>
<span class="sd">                extrapolated limit is returned too.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The extrapolated zero-noise limit. If full_output is True, also</span>
<span class="sd">            returns</span>
<span class="sd">            * standard deviation of the extrapolated zero-noise limit,</span>
<span class="sd">            * optimal parameters of the best-fit model,</span>
<span class="sd">            * parameter covariance matrix of best-fit model,</span>
<span class="sd">            * best-fit model as a Callable[[float], float] function.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>

<span class="sd">        Note:</span>
<span class="sd">            This static method computes the zero-noise limit from input</span>
<span class="sd">            parameters. To compute the zero-noise limit from the Factory</span>
<span class="sd">            parameters, use the ``reduce`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">opt_params</span><span class="p">,</span> <span class="n">params_cov</span> <span class="o">=</span> <span class="n">mitiq_polyfit</span><span class="p">(</span>
            <span class="n">scale_factors</span><span class="p">,</span> <span class="n">exp_values</span><span class="p">,</span> <span class="n">order</span>
        <span class="p">)</span>

        <span class="n">zne_limit</span> <span class="o">=</span> <span class="n">opt_params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">full_output</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zne_limit</span>

        <span class="n">zne_error</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">params_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">params_cov</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">zne_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">params_cov</span><span class="p">[</span><span class="n">order</span><span class="p">,</span> <span class="n">order</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">zne_curve</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">opt_params</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">zne_limit</span><span class="p">,</span> <span class="n">zne_error</span><span class="p">,</span> <span class="n">opt_params</span><span class="p">,</span> <span class="n">params_cov</span><span class="p">,</span> <span class="n">zne_curve</span></div></div>


<div class="viewcode-block" id="RichardsonFactory"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.RichardsonFactory">[docs]</a><span class="k">class</span> <span class="nc">RichardsonFactory</span><span class="p">(</span><span class="n">BatchedFactory</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Factory object implementing Richardson extrapolation.</span>

<span class="sd">    Args:</span>
<span class="sd">        scale_factors: Sequence of noise scale factors at which</span>
<span class="sd">                       expectation values should be measured.</span>
<span class="sd">        shot_list: Optional sequence of integers corresponding to the number</span>
<span class="sd">                   of samples taken for each expectation value. If this</span>
<span class="sd">                   argument is explicitly passed to the factory, it must have</span>
<span class="sd">                   the same length of scale_factors and the executor function</span>
<span class="sd">                   must accept &quot;shots&quot; as a valid keyword argument.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If data is not consistent with the extrapolation model.</span>
<span class="sd">        ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RichardsonFactory.extrapolate"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.RichardsonFactory.extrapolate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">exp_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">full_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExtrapolationResult</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Static method which evaluates the Richardson extrapolation to the</span>
<span class="sd">         zero-noise limit.</span>

<span class="sd">        Args:</span>
<span class="sd">            scale_factors: The array of noise scale factors.</span>
<span class="sd">            exp_values: The array of expectation values.</span>
<span class="sd">            full_output: If False (default), only the zero-noise limit is</span>
<span class="sd">                returned. If True, additional results are returned too.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The extrapolated zero-noise limit. If full_output is True, also</span>
<span class="sd">            returns</span>
<span class="sd">            * standard deviation of the extrapolated zero-noise limit,</span>
<span class="sd">            * optimal parameters of the best-fit model,</span>
<span class="sd">            * parameter covariance matrix of best-fit model,</span>
<span class="sd">            * best-fit model as a Callable[[float], float] function.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>

<span class="sd">        Note:</span>
<span class="sd">            This static method computes the zero-noise limit from input</span>
<span class="sd">            parameters. To compute the zero-noise limit from the Factory</span>
<span class="sd">            parameters, use the ``reduce`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Richardson extrapolation is a particular case of a polynomial fit</span>
        <span class="c1"># with order equal to the number of data points minus 1.</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">PolyFactory</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span>
            <span class="n">scale_factors</span><span class="p">,</span> <span class="n">exp_values</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">full_output</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="FakeNodesFactory"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.FakeNodesFactory">[docs]</a><span class="k">class</span> <span class="nc">FakeNodesFactory</span><span class="p">(</span><span class="n">BatchedFactory</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Factory object implementing a modified version [De2020polynomial]_ of</span>
<span class="sd">    Richardson extrapolation. In this version the original set of scale factors</span>
<span class="sd">    is mapped to a new set of fake nodes, known as Chebyshev-Lobatto points.</span>
<span class="sd">    This method may give a better interpolation for particular types of curves</span>
<span class="sd">    and if the number of scale factors is large (&gt; 10). One should be aware</span>
<span class="sd">    that, in many other cases, the fake nodes extrapolation method is usually</span>
<span class="sd">    not superior to standard Richardson extrapolation.</span>

<span class="sd">    Args:</span>
<span class="sd">        scale_factors: Sequence of noise scale factors at which</span>
<span class="sd">                       expectation values should be measured.</span>
<span class="sd">        shot_list: Optional sequence of integers corresponding to the number</span>
<span class="sd">                   of samples taken for each expectation value. If this</span>
<span class="sd">                   argument is explicitly passed to the factory, it must have</span>
<span class="sd">                   the same length of scale_factors and the executor function</span>
<span class="sd">                   must accept &quot;shots&quot; as a valid keyword argument.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If data is not consistent with the extrapolation model.</span>
<span class="sd">        ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>

<span class="sd">    .. [De2020polynomial] : S.De Marchia. F. Marchetti, E.Perracchionea</span>
<span class="sd">        and D.Poggialia,</span>
<span class="sd">        &quot;Polynomial interpolation via mapped bases without resampling,&quot;</span>
<span class="sd">        *Journ of Comp. and App. Math.* **364**, 112347 (2020),</span>
<span class="sd">        (https://www.sciencedirect.com/science/article/abs/pii/S0377042719303449).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FakeNodesFactory.extrapolate"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.FakeNodesFactory.extrapolate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">exp_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">full_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExtrapolationResult</span><span class="p">:</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">FakeNodesFactory</span><span class="o">.</span><span class="n">_is_equally_spaced</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The scale factors must be equally spaced.&quot;</span><span class="p">)</span>

        <span class="c1"># Define interval [a, b] for which the scale_factors are mapped to</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">)</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">)</span>

        <span class="c1"># Mapping to the fake nodes</span>
        <span class="n">fake_nodes</span> <span class="o">=</span> <span class="n">FakeNodesFactory</span><span class="o">.</span><span class="n">_map_to_fake_nodes</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">full_output</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RichardsonFactory</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span><span class="n">fake_nodes</span><span class="p">,</span> <span class="n">exp_values</span><span class="p">)</span>

        <span class="p">(</span>
            <span class="n">zne_limit</span><span class="p">,</span>
            <span class="n">zne_error</span><span class="p">,</span>
            <span class="n">opt_params</span><span class="p">,</span>
            <span class="n">params_cov</span><span class="p">,</span>
            <span class="n">zne_curve</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">RichardsonFactory</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span>  <span class="c1"># type: ignore[misc]</span>
            <span class="n">fake_nodes</span><span class="p">,</span> <span class="n">exp_values</span><span class="p">,</span> <span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Convert zne_curve from the &quot;fake node space&quot; to the real space.</span>
        <span class="c1"># Note: since a=0.0, this conversion is not necessary for zne_limit.</span>
        <span class="k">def</span> <span class="nf">new_curve</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;Get real zne_curve from the curve based on fake nodes.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">zne_curve</span><span class="p">(</span>
                <span class="n">FakeNodesFactory</span><span class="o">.</span><span class="n">_map_to_fake_nodes</span><span class="p">([</span><span class="n">scale_factor</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">zne_limit</span><span class="p">,</span> <span class="n">zne_error</span><span class="p">,</span> <span class="n">opt_params</span><span class="p">,</span> <span class="n">params_cov</span><span class="p">,</span> <span class="n">new_curve</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_map_to_fake_nodes</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function that maps inputs to Chebyshev-Lobatto points. Based on</span>
<span class="sd">        the function [De2020polynomial]_:</span>
<span class="sd">            S(x) = (a - b)/2 * cos(pi * (x - a)/(b - a)) + (a + b)/2.</span>
<span class="sd">        Where a and b are the endpoints of the interval [a, b] of CL points</span>
<span class="sd">        we are mapping to.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: Sequence[float]: Set of values to be mapped to CL points.</span>
<span class="sd">            a: A float representing the interval starting at a.</span>
<span class="sd">            b: A float representing the interval ending at b.</span>
<span class="sd">        Returns:</span>
<span class="sd">            A new sequence of fake nodes (Chebyshev-Lobatto points).</span>

<span class="sd">        .. [De2020polynomial]: S.De Marchia. F. Marchetti, E.Perracchionea</span>
<span class="sd">            and D.Poggialia,</span>
<span class="sd">            &quot;Polynomial interpolation via mapped bases without resampling,&quot;</span>
<span class="sd">            *Journ of Comp. and App. Math.* **364**, 112347 (2020),</span>
<span class="sd">            (https://www.sciencedirect.com/science/article/abs/pii/S0377042719303449).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The mapping function</span>
        <span class="k">def</span> <span class="nf">mapping</span><span class="p">(</span><span class="n">_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">_x</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span>
                <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
            <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">mapping</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_equally_spaced</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Checks if the sequence is equally spaced.&quot;&quot;&quot;</span>

        <span class="n">diff_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">diff_arr</span><span class="p">,</span> <span class="n">diff_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="LinearFactory"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.LinearFactory">[docs]</a><span class="k">class</span> <span class="nc">LinearFactory</span><span class="p">(</span><span class="n">BatchedFactory</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factory object implementing zero-noise extrapolation based</span>
<span class="sd">    on a linear fit.</span>

<span class="sd">    Args:</span>
<span class="sd">        scale_factors: Sequence of noise scale factors at which</span>
<span class="sd">                       expectation values should be measured.</span>
<span class="sd">        shot_list: Optional sequence of integers corresponding to the number</span>
<span class="sd">                   of samples taken for each expectation value. If this</span>
<span class="sd">                   argument is explicitly passed to the factory, it must have</span>
<span class="sd">                   the same length of scale_factors and the executor function</span>
<span class="sd">                   must accept &quot;shots&quot; as a valid keyword argument.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If data is not consistent with the extrapolation model.</span>
<span class="sd">        ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LinearFactory.extrapolate"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.LinearFactory.extrapolate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">exp_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">full_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExtrapolationResult</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Static method which evaluates the linear extrapolation to the</span>
<span class="sd">        zero-noise limit.</span>

<span class="sd">        Args:</span>
<span class="sd">            scale_factors: The array of noise scale factors.</span>
<span class="sd">            exp_values: The array of expectation values.</span>
<span class="sd">            full_output: If False (default), only the zero-noise limit is</span>
<span class="sd">                returned. If True, additional results are returned too.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The extrapolated zero-noise limit. If full_output is True, also</span>
<span class="sd">            returns</span>
<span class="sd">            * standard deviation of the extrapolated zero-noise limit,</span>
<span class="sd">            * optimal parameters of the best-fit model,</span>
<span class="sd">            * parameter covariance matrix of best-fit model,</span>
<span class="sd">            * best-fit model as a Callable[[float], float] function.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>

<span class="sd">        Note:</span>
<span class="sd">            This static method computes the zero-noise limit from input</span>
<span class="sd">            parameters. To compute the zero-noise limit from the Factory</span>
<span class="sd">            parameters, use the ``reduce`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Linear extrapolation is equivalent to a polynomial fit with order=1</span>
        <span class="k">return</span> <span class="n">PolyFactory</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span>
            <span class="n">scale_factors</span><span class="p">,</span> <span class="n">exp_values</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">full_output</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="ExpFactory"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.ExpFactory">[docs]</a><span class="k">class</span> <span class="nc">ExpFactory</span><span class="p">(</span><span class="n">BatchedFactory</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factory object implementing a zero-noise extrapolation algorithm assuming</span>
<span class="sd">    an exponential ansatz y(x) = a + b * exp(-c * x), with c &gt; 0.</span>

<span class="sd">    If y(x-&gt;inf) is unknown, the ansatz y(x) is fitted with a non-linear</span>
<span class="sd">    optimization.</span>

<span class="sd">    If y(x-&gt;inf) is given and avoid_log=False, the exponential</span>
<span class="sd">    model is mapped into a linear model by a logarithmic transformation.</span>

<span class="sd">    Args:</span>
<span class="sd">        scale_factors: Sequence of noise scale factors at which expectation</span>
<span class="sd">            values should be measured.</span>
<span class="sd">        asymptote: Infinite-noise limit (optional argument).</span>
<span class="sd">        avoid_log: If set to True, the exponential model is not linearized</span>
<span class="sd">            with a logarithm and a non-linear fit is applied even if asymptote</span>
<span class="sd">            is not None. The default value is False.</span>
<span class="sd">        shot_list: Optional sequence of integers corresponding to the number</span>
<span class="sd">            of samples taken for each expectation value. If this argument is</span>
<span class="sd">            explicitly passed to the factory, it must have the same length of</span>
<span class="sd">            scale_factors and the executor function must accept &quot;shots&quot; as a</span>
<span class="sd">            valid keyword argument.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If data is not consistent with the extrapolation model.</span>
<span class="sd">        ExtrapolationError: If the extrapolation fit fails.</span>
<span class="sd">        ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">asymptote</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">avoid_log</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">shot_list</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Instantiate an new object of this Factory class.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ExpFactory</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">,</span> <span class="n">shot_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">asymptote</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">asymptote</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The argument &#39;asymptote&#39; must be either a float or None&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_options</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;asymptote&quot;</span><span class="p">:</span> <span class="n">asymptote</span><span class="p">,</span>
            <span class="s2">&quot;avoid_log&quot;</span><span class="p">:</span> <span class="n">avoid_log</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="ExpFactory.extrapolate"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.ExpFactory.extrapolate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">exp_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">asymptote</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">avoid_log</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0e-6</span><span class="p">,</span>
        <span class="n">full_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExtrapolationResult</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Static method which evaluates the extrapolation to the zero-noise</span>
<span class="sd">        limit assuming an exponential ansatz y(x) = a + b * exp(-c * x),</span>
<span class="sd">        with c &gt; 0.</span>

<span class="sd">        If y(x-&gt;inf) is unknown, the ansatz y(x) is fitted with a non-linear</span>
<span class="sd">        optimization.</span>

<span class="sd">        If y(x-&gt;inf) is given and avoid_log=False, the exponential</span>
<span class="sd">        model is mapped into a linear model by a logarithmic transformation.</span>

<span class="sd">        Args:</span>
<span class="sd">            scale_factors: The array of noise scale factors.</span>
<span class="sd">            exp_values: The array of expectation values.</span>
<span class="sd">            asymptote: The infinite-noise limit y(x-&gt;inf) (optional argument).</span>
<span class="sd">            avoid_log: If set to True, the exponential model is not linearized</span>
<span class="sd">                with a logarithm and a non-linear fit is applied even if</span>
<span class="sd">                asymptote is not None. The default value is False.</span>
<span class="sd">            eps: Epsilon to regularize log(sign(scale_factors - asymptote))</span>
<span class="sd">                when the argument is to close to zero or negative.</span>
<span class="sd">            full_output: If False (default), only the zero-noise limit is</span>
<span class="sd">                returned. If True, additional information about the</span>
<span class="sd">                extrapolated limit is returned too.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The extrapolated zero-noise limit. If full_output is True, also</span>
<span class="sd">            returns</span>
<span class="sd">            * standard deviation of the extrapolated zero-noise limit,</span>
<span class="sd">            * optimal parameters of the best-fit model,</span>
<span class="sd">            * parameter covariance matrix of best-fit model,</span>
<span class="sd">            * best-fit model as a Callable[[float], float] function.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the arguments are not consistent with the</span>
<span class="sd">                extrapolation model.</span>
<span class="sd">            ExtrapolationError: If the extrapolation fit fails.</span>
<span class="sd">            ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>

<span class="sd">        Note:</span>
<span class="sd">            This static method computes the zero-noise limit from input</span>
<span class="sd">            parameters. To compute the zero-noise limit from the Factory</span>
<span class="sd">            parameters, use the ``reduce`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PolyExpFactory</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span>
            <span class="n">scale_factors</span><span class="p">,</span>
            <span class="n">exp_values</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">asymptote</span><span class="o">=</span><span class="n">asymptote</span><span class="p">,</span>
            <span class="n">avoid_log</span><span class="o">=</span><span class="n">avoid_log</span><span class="p">,</span>
            <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="PolyExpFactory"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.PolyExpFactory">[docs]</a><span class="k">class</span> <span class="nc">PolyExpFactory</span><span class="p">(</span><span class="n">BatchedFactory</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factory object implementing a zero-noise extrapolation algorithm assuming</span>
<span class="sd">    an (almost) exponential ansatz with a non linear exponent</span>
<span class="sd">    y(x) = a + sign * exp(z(x)), where z(x) is a polynomial of a given order.</span>

<span class="sd">    The parameter &quot;sign&quot; is a sign variable which can be either 1 or -1,</span>
<span class="sd">    corresponding to decreasing and increasing exponentials, respectively.</span>
<span class="sd">    The parameter &quot;sign&quot; is automatically deduced from the data.</span>

<span class="sd">    If y(x-&gt;inf) is unknown, the ansatz y(x) is fitted with a non-linear</span>
<span class="sd">    optimization.</span>

<span class="sd">    If y(x-&gt;inf) is given and avoid_log=False, the exponential</span>
<span class="sd">    model is mapped into a polynomial model by logarithmic transformation.</span>

<span class="sd">    Args:</span>
<span class="sd">        scale_factors: Sequence of noise scale factors at which</span>
<span class="sd">                       expectation values should be measured.</span>
<span class="sd">        order: Extrapolation order (degree of the polynomial z(x)).</span>
<span class="sd">               It cannot exceed len(scale_factors) - 1.</span>
<span class="sd">               If asymptote is None, order cannot exceed</span>
<span class="sd">               len(scale_factors) - 2.</span>
<span class="sd">        asymptote: The infinite-noise limit y(x-&gt;inf) (optional argument).</span>
<span class="sd">        avoid_log: If set to True, the exponential model is not linearized</span>
<span class="sd">                   with a logarithm and a non-linear fit is applied even</span>
<span class="sd">                   if asymptote is not None. The default value is False.</span>
<span class="sd">        shot_list: Optional sequence of integers corresponding to the number</span>
<span class="sd">                   of samples taken for each expectation value. If this</span>
<span class="sd">                   argument is explicitly passed to the factory, it must have</span>
<span class="sd">                   the same length of scale_factors and the executor function</span>
<span class="sd">                   must accept &quot;shots&quot; as a valid keyword argument.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If data is not consistent with the extrapolation model.</span>
<span class="sd">        ExtrapolationError: If the extrapolation fit fails.</span>
<span class="sd">        ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">asymptote</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">avoid_log</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">shot_list</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Instantiates a new object of this Factory class.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PolyExpFactory</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">,</span> <span class="n">shot_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">asymptote</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">asymptote</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The argument &#39;asymptote&#39; must be either a float or None&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_options</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;order&quot;</span><span class="p">:</span> <span class="n">order</span><span class="p">,</span>
            <span class="s2">&quot;asymptote&quot;</span><span class="p">:</span> <span class="n">asymptote</span><span class="p">,</span>
            <span class="s2">&quot;avoid_log&quot;</span><span class="p">:</span> <span class="n">avoid_log</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="PolyExpFactory.extrapolate"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.PolyExpFactory.extrapolate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">exp_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">asymptote</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">avoid_log</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0e-6</span><span class="p">,</span>
        <span class="n">full_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExtrapolationResult</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Static method which evaluates the extrapolation to the</span>
<span class="sd">        zero-noise limit with an exponential ansatz (whose exponent</span>
<span class="sd">        is a polynomial of degree &quot;order&quot;).</span>

<span class="sd">        The exponential ansatz is y(x) = a + sign * exp(z(x)) where z(x) is a</span>
<span class="sd">        polynomial and &quot;sign&quot; is either +1 or -1 corresponding to decreasing</span>
<span class="sd">        and increasing exponentials, respectively. The parameter &quot;sign&quot; is</span>
<span class="sd">        automatically deduced from the data.</span>

<span class="sd">        It is also assumed that z(x--&gt;inf) = -inf, such that y(x--&gt;inf) --&gt; a.</span>

<span class="sd">        If asymptote is None, the ansatz y(x) is fitted with a non-linear</span>
<span class="sd">        optimization.</span>

<span class="sd">        If asymptote is given and avoid_log=False, a linear fit with respect to</span>
<span class="sd">        z(x) := log[sign * (y(x) - asymptote)] is performed.</span>

<span class="sd">        Args:</span>
<span class="sd">            scale_factors: The array of noise scale factors.</span>
<span class="sd">            exp_values: The array of expectation values.</span>
<span class="sd">            asymptote: The infinite-noise limit y(x-&gt;inf) (optional argument).</span>
<span class="sd">            order: The degree of the polynomial z(x).</span>
<span class="sd">            avoid_log: If set to True, the exponential model is not linearized</span>
<span class="sd">                with a logarithm and a non-linear fit is applied even if</span>
<span class="sd">                asymptote is not None. The default value is False.</span>
<span class="sd">            eps: Epsilon to regularize log(sign(scale_factors - asymptote))</span>
<span class="sd">                when the argument is to close to zero or negative.</span>
<span class="sd">            full_output: If False (default), only the zero-noise limit is</span>
<span class="sd">                returned. If True, additional information about the</span>
<span class="sd">                extrapolated limit is returned too.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The extrapolated zero-noise limit. If full_output is True, also</span>
<span class="sd">            returns</span>
<span class="sd">            * standard deviation of the extrapolated zero-noise limit,</span>
<span class="sd">            * optimal parameters of the best-fit model,</span>
<span class="sd">            * parameter covariance matrix of best-fit model,</span>
<span class="sd">            * best-fit model as a Callable[[float], float] function.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the arguments are not consistent with the</span>
<span class="sd">                extrapolation model.</span>
<span class="sd">            ExtrapolationError: If the extrapolation fit fails.</span>
<span class="sd">            ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>

<span class="sd">        Note:</span>
<span class="sd">            This static method computes the zero-noise limit from input</span>
<span class="sd">            parameters. To compute the zero-noise limit from the Factory</span>
<span class="sd">            parameters, use the ``reduce`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Shift is 0 if asymptote is given, 1 if asymptote is not given</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">asymptote</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Check arguments</span>
        <span class="n">error_str</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Data is not enough: at least two data points are necessary.&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">scale_factors</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">exp_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_str</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exp_values</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">shift</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Extrapolation order is too high. &quot;</span>
                <span class="s2">&quot;The order cannot exceed the number&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; of data points minus </span><span class="si">{</span><span class="mi">1</span> <span class="o">+</span> <span class="n">shift</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">exp_values</span><span class="p">),</span> <span class="n">exp_values</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot extrapolate: Some expectation values in </span><span class="si">{</span><span class="n">exp_values</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;have non-zero imaginary part.&quot;</span>
            <span class="p">)</span>
        <span class="n">exp_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">exp_values</span><span class="p">)</span>

        <span class="c1"># Initialize default errors</span>
        <span class="n">zne_error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">params_cov</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Deduce &quot;sign&quot; parameter of the exponential ansatz</span>
        <span class="n">linear_params</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mitiq_polyfit</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">,</span> <span class="n">exp_values</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="o">-</span><span class="n">linear_params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">_ansatz_unknown</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="o">*</span><span class="n">coeffs</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;Ansatz of generic order with unknown asymptote.&quot;&quot;&quot;</span>
            <span class="c1"># Coefficients of the polynomial to be exponentiated</span>
            <span class="n">z_coeffs</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">2</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">z_coeffs</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">_ansatz_known</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="o">*</span><span class="n">coeffs</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;Ansatz of generic order with known asymptote.&quot;&quot;&quot;</span>
            <span class="c1"># Coefficients of the polynomial to be exponentiated</span>
            <span class="n">z_coeffs</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">asymptote</span> <span class="o">+</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">z_coeffs</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>

        <span class="c1"># CASE 1: asymptote is None.</span>
        <span class="k">if</span> <span class="n">asymptote</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># First guess for the parameters</span>
            <span class="n">p_zero</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">opt_params</span><span class="p">,</span> <span class="n">params_cov</span> <span class="o">=</span> <span class="n">mitiq_curve_fit</span><span class="p">(</span>
                <span class="n">_ansatz_unknown</span><span class="p">,</span> <span class="n">scale_factors</span><span class="p">,</span> <span class="n">exp_values</span><span class="p">,</span> <span class="n">p_zero</span>
            <span class="p">)</span>
            <span class="c1"># The zero noise limit is ansatz(0)= asympt + b</span>
            <span class="n">zne_limit</span> <span class="o">=</span> <span class="n">opt_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">opt_params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">zne_curve</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_ansatz_unknown</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">,</span> <span class="o">*</span><span class="n">opt_params</span><span class="p">)</span>

            <span class="c1"># Use propagation of errors to calculate zne_error</span>
            <span class="k">if</span> <span class="n">params_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">params_cov</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">zne_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="n">params_cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">params_cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="o">+</span> <span class="n">params_cov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="n">full_output</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">zne_limit</span><span class="p">,</span>
                    <span class="n">zne_error</span><span class="p">,</span>
                    <span class="n">opt_params</span><span class="p">,</span>
                    <span class="n">params_cov</span><span class="p">,</span>
                    <span class="n">zne_curve</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">zne_limit</span>

        <span class="c1"># CASE 2: asymptote is given and &quot;avoid_log&quot; is True</span>
        <span class="k">if</span> <span class="n">avoid_log</span><span class="p">:</span>
            <span class="c1"># First guess for the parameters</span>
            <span class="n">p_zero</span> <span class="o">=</span> <span class="p">[</span><span class="n">sign</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">opt_params</span><span class="p">,</span> <span class="n">params_cov</span> <span class="o">=</span> <span class="n">mitiq_curve_fit</span><span class="p">(</span>
                <span class="n">_ansatz_known</span><span class="p">,</span> <span class="n">scale_factors</span><span class="p">,</span> <span class="n">exp_values</span><span class="p">,</span> <span class="n">p_zero</span>
            <span class="p">)</span>
            <span class="c1"># The zero noise limit is ansatz(0)= asymptote + b</span>
            <span class="n">zne_limit</span> <span class="o">=</span> <span class="n">asymptote</span> <span class="o">+</span> <span class="n">opt_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">zne_curve</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_ansatz_known</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">,</span> <span class="o">*</span><span class="n">opt_params</span><span class="p">)</span>

            <span class="c1"># Use propagation of errors to calculate zne_error</span>
            <span class="k">if</span> <span class="n">params_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">params_cov</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">zne_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">params_cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

            <span class="n">opt_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">asymptote</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">opt_params</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">full_output</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">zne_limit</span><span class="p">,</span>
                    <span class="n">zne_error</span><span class="p">,</span>
                    <span class="n">opt_params</span><span class="p">,</span>
                    <span class="n">params_cov</span><span class="p">,</span>
                    <span class="n">zne_curve</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">zne_limit</span>

        <span class="c1"># CASE 3: asymptote is given and &quot;avoid_log&quot; is False</span>
        <span class="c1"># Polynomial fit of z(x).</span>
        <span class="n">shifted_y</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">sign</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">asymptote</span><span class="p">),</span> <span class="n">eps</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">exp_values</span><span class="p">]</span>
        <span class="n">zstack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">shifted_y</span><span class="p">)</span>

        <span class="c1"># Get coefficients {z_j} of z(x)= z_0 + z_1*x + z_2*x**2...</span>
        <span class="c1"># Note: coefficients are ordered from high powers to powers of x</span>
        <span class="c1"># Weights &quot;w&quot; are used to compensate for error propagation</span>
        <span class="c1"># after the log transformation y --&gt; z</span>
        <span class="n">z_coefficients</span><span class="p">,</span> <span class="n">param_cov</span> <span class="o">=</span> <span class="n">mitiq_polyfit</span><span class="p">(</span>
            <span class="n">scale_factors</span><span class="p">,</span>
            <span class="n">zstack</span><span class="p">,</span>
            <span class="n">deg</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">shifted_y</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="c1"># The zero noise limit is ansatz(0)</span>
        <span class="n">zne_limit</span> <span class="o">=</span> <span class="n">asymptote</span> <span class="o">+</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z_coefficients</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">_zne_curve</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">asymptote</span> <span class="o">+</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">z_coefficients</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Use propagation of errors to calculate zne_error</span>
        <span class="k">if</span> <span class="n">params_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">params_cov</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">zne_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z_coefficients</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="n">params_cov</span><span class="p">[</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="c1"># Parameters from low order to high order</span>
        <span class="n">opt_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">asymptote</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">z_coefficients</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">full_output</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zne_limit</span><span class="p">,</span> <span class="n">zne_error</span><span class="p">,</span> <span class="n">opt_params</span><span class="p">,</span> <span class="n">params_cov</span><span class="p">,</span> <span class="n">_zne_curve</span>
        <span class="k">return</span> <span class="n">zne_limit</span></div></div>


<span class="c1"># Keep a log of the optimization process storing:</span>
<span class="c1"># noise value(s), expectation value(s), parameters, and zero limit</span>
<span class="n">OptimizationHistory</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span>
<span class="p">]</span>


<div class="viewcode-block" id="AdaExpFactory"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.AdaExpFactory">[docs]</a><span class="k">class</span> <span class="nc">AdaExpFactory</span><span class="p">(</span><span class="n">AdaptiveFactory</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Factory object implementing an adaptive zero-noise extrapolation</span>
<span class="sd">    algorithm assuming an exponential ansatz y(x) = a + b * exp(-c * x),</span>
<span class="sd">    with c &gt; 0.</span>

<span class="sd">    The noise scale factors are are chosen adaptively at each step,</span>
<span class="sd">    depending on the history of collected results.</span>

<span class="sd">    If y(x-&gt;inf) is unknown, the ansatz y(x) is fitted with a non-linear</span>
<span class="sd">    optimization.</span>

<span class="sd">    If y(x-&gt;inf) is given and avoid_log=False, the exponential</span>
<span class="sd">    model is mapped into a linear model by logarithmic transformation.</span>

<span class="sd">    Args:</span>
<span class="sd">        steps: The number of optimization steps. At least 3 are necessary.</span>
<span class="sd">        scale_factor: The second noise scale factor (the first is always 1.0).</span>
<span class="sd">            Further scale factors are adaptively determined.</span>
<span class="sd">        asymptote: The infinite-noise limit y(x-&gt;inf) (optional argument).</span>
<span class="sd">        avoid_log: If set to True, the exponential model is not linearized</span>
<span class="sd">            with a logarithm and a non-linear fit is applied even if asymptote</span>
<span class="sd">            is not None. The default value is False.</span>
<span class="sd">        max_scale_factor: Maximum noise scale factor. Default is 6.0.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If data is not consistent with the extrapolation model.</span>
<span class="sd">        ExtrapolationError: If the extrapolation fit fails.</span>
<span class="sd">        ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_SHIFT_FACTOR</span> <span class="o">=</span> <span class="mf">1.27846</span>
    <span class="n">_EPSILON</span> <span class="o">=</span> <span class="mf">1.0e-9</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">scale_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">asymptote</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">avoid_log</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_scale_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">6.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Instantiate a new object of this Factory class.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AdaExpFactory</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">asymptote</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">asymptote</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The argument &#39;asymptote&#39; must be either a float or None&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">scale_factor</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The argument &#39;scale_factor&#39; must be strictly larger than one.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">steps</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">asymptote</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The argument &#39;steps&#39; must be an integer&quot;</span>
                <span class="s2">&quot; greater or equal to 3. &quot;</span>
                <span class="s2">&quot;If &#39;asymptote&#39; is None, &#39;steps&#39; must be&quot;</span>
                <span class="s2">&quot; greater or equal to 4.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">max_scale_factor</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The argument &#39;max_scale_factor&#39; must be&quot;</span>
                <span class="s2">&quot; strictly larger than one.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_steps</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale_factor</span> <span class="o">=</span> <span class="n">scale_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asymptote</span> <span class="o">=</span> <span class="n">asymptote</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avoid_log</span> <span class="o">=</span> <span class="n">avoid_log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_scale_factor</span> <span class="o">=</span> <span class="n">max_scale_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">:</span> <span class="n">OptimizationHistory</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="AdaExpFactory.next"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.AdaExpFactory.next">[docs]</a>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns a dictionary of parameters to execute a circuit at.&quot;&quot;&quot;</span>
        <span class="c1"># The 1st scale factor is always 1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">}</span>
        <span class="c1"># The 2nd scale factor is self._scale_factor</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_factor</span><span class="p">}</span>
        <span class="c1"># If asymptote is None we use 2 * scale_factor as third noise parameter</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asymptote</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_factor</span><span class="p">}</span>

        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="c1"># This is an intermediate fit, so we suppress its warning messages</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">ExtrapolationWarning</span><span class="p">)</span>
            <span class="c1"># Call reduce() to fit the exponent and save it in self.history</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
            <span class="c1"># The next line avoids warnings after intermediate extrapolations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_already_reduced</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Get the most recent fitted parameters from self.history</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># The exponent parameter is the 3rd element of params</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># Further noise scale factors are determined with</span>
        <span class="c1"># an adaptive rule which depends on self.exponent</span>
        <span class="n">next_scale_factor</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SHIFT_FACTOR</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">exponent</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EPSILON</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_scale_factor</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">:</span> <span class="n">next_scale_factor</span><span class="p">}</span></div>

<div class="viewcode-block" id="AdaExpFactory.is_converged"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.AdaExpFactory.is_converged">[docs]</a>    <span class="k">def</span> <span class="nf">is_converged</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns True if all the needed expectation values have been</span>
<span class="sd">        computed, else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outstack</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instack</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The length of &#39;self._instack&#39; (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instack</span><span class="p">)</span><span class="si">}</span><span class="s2">) &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;and &#39;self._outstack&#39; (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outstack</span><span class="p">)</span><span class="si">}</span><span class="s2">) must be equal.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outstack</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_steps</span></div>

<div class="viewcode-block" id="AdaExpFactory.extrapolate"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.AdaExpFactory.extrapolate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">exp_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">asymptote</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">avoid_log</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0e-6</span><span class="p">,</span>
        <span class="n">full_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExtrapolationResult</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Static method which evaluates the extrapolation to the zero-noise</span>
<span class="sd">        limit assuming an exponential ansatz y(x) = a + b * exp(-c * x),</span>
<span class="sd">        with c &gt; 0.</span>

<span class="sd">        If y(x-&gt;inf) is unknown, the ansatz y(x) is fitted with a non-linear</span>
<span class="sd">        optimization.</span>

<span class="sd">        If y(x-&gt;inf) is given and avoid_log=False, the exponential</span>
<span class="sd">        model is mapped into a linear model by a logarithmic transformation.</span>

<span class="sd">        Args:</span>
<span class="sd">            scale_factors: The array of noise scale factors.</span>
<span class="sd">            exp_values: The array of expectation values.</span>
<span class="sd">            asymptote: The infinite-noise limit y(x-&gt;inf) (optional argument).</span>
<span class="sd">            avoid_log: If set to True, the exponential model is not linearized</span>
<span class="sd">                with a logarithm and a non-linear fit is applied even if</span>
<span class="sd">                asymptote is not None. The default value is False.</span>
<span class="sd">            eps: Epsilon to regularize log(sign(scale_factors - asymptote))</span>
<span class="sd">                when the argument is to close to zero or negative.</span>
<span class="sd">            full_output: If False (default), only the zero-noise limit is</span>
<span class="sd">                returned. If True, additional results are returned too.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The extrapolated zero-noise limit. If full_output is True, also</span>
<span class="sd">            returns</span>
<span class="sd">            * standard deviation of the extrapolated zero-noise limit,</span>
<span class="sd">            * optimal parameters of the best-fit model,</span>
<span class="sd">            * parameter covariance matrix of best-fit model,</span>
<span class="sd">            * best-fit model as a Callable[[float], float] function.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the arguments are not consistent with the</span>
<span class="sd">                extrapolation model.</span>
<span class="sd">            ExtrapolationError: If the extrapolation fit fails.</span>
<span class="sd">            ExtrapolationWarning: If the extrapolation fit is ill-conditioned.</span>

<span class="sd">        Note:</span>
<span class="sd">            This static method computes the zero-noise limit from input</span>
<span class="sd">            parameters. To compute the zero-noise limit from the Factory</span>
<span class="sd">            parameters, use the ``reduce`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ExpFactory</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span>
            <span class="n">scale_factors</span><span class="p">,</span>
            <span class="n">exp_values</span><span class="p">,</span>
            <span class="n">asymptote</span><span class="o">=</span><span class="n">asymptote</span><span class="p">,</span>
            <span class="n">avoid_log</span><span class="o">=</span><span class="n">avoid_log</span><span class="p">,</span>
            <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="AdaExpFactory.reduce"><a class="viewcode-back" href="../../../apidoc.html#mitiq.zne.inference.AdaExpFactory.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the zero-noise limit found by fitting an exponential</span>
<span class="sd">        model to the internal data stored in the factory.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The zero-noise limit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zne_limit</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zne_error</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_params</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params_cov</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zne_curve</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
            <span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scale_factors</span><span class="p">()),</span>
            <span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_expectation_values</span><span class="p">()),</span>
            <span class="n">asymptote</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">asymptote</span><span class="p">,</span>
            <span class="n">avoid_log</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">avoid_log</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Update optimization history</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instack</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outstack</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zne_limit</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_already_reduced</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zne_limit</span></div></div>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          
    
<!--
    Adds link to GitHub repository as an animated SVG in the top-right corner
    of the documentation.
    
    Source: github-corners https://github.com/tholman/github-corners

    License:
    The MIT License (MIT)

    Copyright (c) 2016 Tim Holman

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation 
    the rights to use, copy, modify, merge, publish, distribute, sublicense, 
    and/or sell copies of the Software, and to permit persons to whom the 
    Software is furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in 
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
    DEALINGS IN THE SOFTWARE.
-->
<a href="https://github.com/unitaryfund/mitiq" class="github-corner" aria-label="View source on GitHub">
    <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 60; border: 0; right: 0;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>



      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020, Tech Team @ Unitary Fund.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>